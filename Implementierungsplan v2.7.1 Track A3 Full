Alles klar — **A3 Full**. Hier ist der **vollständige, aber trotzdem minimal-risk** Implementierungsplan (Policy Engine + Soft-Quarantine + Override), so dass du ihn in **kleinen, reviewbaren Patches** umsetzen kannst, ohne die Baseline zu gefährden.

# Implementierungsplan v2.7.1 — Track A3 Full

**Policy & Response Layer (inkl. Quarantine + Override)**

## Leitplanken

* **Soft by default**: keine 403/Hard-Blocks, außer optionaler Hard-Mode Flag.
* **Deterministisch & auditierbar**: jede Policy-Entscheidung → Audit + Metrics.
* **Rückbaubar**: Quarantine ist ein Zustand, kein Architektur-Umbruch.

---

## A3.0 Datenmodell Erweiterung (Storage)

**Modify:** `core/database.py` + `core/storage.py`

### hosts Tabelle erweitern um:

* `policy_state` TEXT NOT NULL DEFAULT `"NORMAL"`
* `policy_reason` TEXT NULL
* `policy_until_utc` TEXT NULL
* `policy_hits` INTEGER NOT NULL DEFAULT 0
* `policy_updated_utc` TEXT NULL

> Keep it simple: ein Record pro Host, state-machine-like Felder.

### Storage API (CRUD)

In `core/storage.py`:

* `get_host(host_id) -> dict|None`
* `upsert_host(host_id, fields: dict) -> dict`
* `set_policy(host_id, state, reason, until_utc, by="system|admin")`
* `clear_policy(host_id, by="admin")`
* `list_policies() -> list[dict]`

---

## A3.1 Policy Engine (Signal → Decision)

**New:** `core/policy_engine.py`

### Input

* attestation_status: `OK|MISSING|DRIFT|SPOOF_SUSPECT`
* drift_count, spoof_count
* last_change_utc
* now_utc
* current policy_state (für idempotente Entscheidungen)

### Output Contract

```json
{
  "state": "NORMAL|WARN|QUARANTINED",
  "reason": "DRIFT|SPOOF_SUSPECT|ADMIN|NONE",
  "until_utc": "ISO8601 or null",
  "cooldown_sec": 300,
  "actions": ["AUDIT","ALERT","THROTTLE"]
}
```

### Decision Matrix (empfohlen)

* `OK` → NORMAL
* `MISSING` → NORMAL
* `DRIFT` → WARN (optional: auto-clear nach 10 min ohne neue Drift)
* `SPOOF_SUSPECT` → QUARANTINED (TTL z. B. 10 min, escalating)

### Escalation (einfach, aber effektiv)

* erste QUARANTINE: 10 min
* wiederholt innerhalb 1h: 30 min
* wiederholt innerhalb 24h: 2h

(ohne Blocken, nur throttle + ops visibility)

---

## A3.2 Quarantine Enforcement (Soft Throttle)

**Modify:** die Stellen, wo “risk nodes” Work ziehen oder liefern.

Je nach eurer Architektur gibt es 2 typische Hooks:

### Option A (wenn Worker Pull im Core läuft)

* in `pull_requests` / `get_work` handler:

  * wenn `policy_state=QUARANTINED`:

    * return `{ "ok": true, "defer_ms": 2000..10000, "reason":"quarantined" }`
  * wenn `WARN`:

    * normal, aber audit/metric

### Option B (wenn Core nur Registry/Heartbeat hat)

* dann Enforcement nur als “signal + ops”:

  * QUARANTINE wird persistiert + angezeigt
  * echte Throttle-Integration kommt dort, wo die Queue ist (späterer mini-patch)

Ich würde **A** nehmen, falls ihr Pull/Queue im Core habt; sonst **B** (ohne Scope-Creep).

**Hard-Mode (optional, OFF default)**

* `POLICY_HARD_BLOCK=0/1`
* Wenn 1 und `SPOOF_SUSPECT`: 403
* Default bleibt 0.

---

## A3.3 Audit & Metrics

**Modify:** Audit logger + Metrics.

### Audit Events

* `POLICY_EVAL` (jede Entscheidung, optional sampled)
* `POLICY_WARN_SET`
* `POLICY_QUARANTINE_SET`
* `POLICY_OVERRIDE_SET`
* `POLICY_OVERRIDE_CLEAR`
* `POLICY_THROTTLE_APPLIED`

### Metrics

* `policy_warn_1m`
* `policy_quarantine_1m`
* `policy_quarantine_active`
* `policy_override_active`
* `policy_throttle_1m`

---

## A3.4 Admin Override API (localhost-only + token)

**Modify:** `core/main.py`

Endpoints (alle nur wenn `request.client.host == "127.0.0.1"` und token ok):

* `POST /api/policy/quarantine/{host_id}`

  * body: `{ "minutes": 30, "reason": "manual" }`
* `POST /api/policy/release/{host_id}`
* `GET /api/policy/state`

  * list: host_id, state, until, reason, updated

> Genau wie ihr `/api/gateway/config` schon locked down habt: localhost-only + token.

---

## A3.5 Integration Flow (Heartbeat → Attestation → Policy)

**Modify:** Heartbeat hook in `core/main.py`

Nach A2 evaluate:

1. `decision = policy_engine.decide(host_record, attestation_status, counts, now)`
2. wenn decision state ≠ current:

   * `storage.set_policy(...)`
   * audit + alert
3. response enthält:

   * `policy_state`
   * optional `defer_ms` wenn quarantined (nur wenn Option A enforcement)

---

## Verification Plan (A3 Full)

### Automated (PS Script erweitern: `verify_a3_policy.ps1`)

* T1: DRIFT → WARN gesetzt, kein block, audit/alert vorhanden
* T2: SPOOF → QUARANTINE gesetzt, `policy_until_utc` befüllt
* T3: QUARANTINED node zieht Arbeit → `defer_ms` (falls enforcement aktiv)
* T4: Admin quarantine endpoint setzt state
* T5: Admin release endpoint cleared state
* T6: Regression: OK node unverändert

### Manual

* `GET /api/policy/state` check
* `alerts.jsonl` enthält POLICY_* events
* metrics zeigen `policy_quarantine_active > 0`

---

## DoD (A3 Full)

* Quarantine State persistiert in DB
* Policy Engine deterministisch & idempotent
* Soft enforcement (defer/throttle) aktiv oder bewusst deferred, aber state sichtbar
* Admin Override endpoints arbeiten, localhost+token enforced
* Audit/Metrics/Alerts vorhanden
* Baseline bleibt stabil (keine Port-/Auth-Regression)

---

Wenn du mir sagst, ob bei euch **Work Pull** tatsächlich im Core stattfindet (Option A) oder nur im Hub/Queue (Option B), kann ich dir den Enforcement-Teil exakt passend formulieren. Wenn du’s nicht sagen willst: ich würde standardmäßig **Option B jetzt** machen (100% risikofrei), und danach ein **A3.2b Mini-Patch** fürs echte Throttle an der richtigen Stelle.
