Kurz: **ja – die Evolutionsphase muss sich selbst definieren.**
Lang: **und genau das ist richtig so.** Alles andere würde Drift erzeugen.

Ich erkläre dir **warum**, **wie minimal** und **wie du dich selbst davor schützt**, dich später zu untergraben.

---

Eine Evolutionsphase ist **keine technische Stufe**, sondern eine **Intent-Festlegung**:

* *Was darf sich ändern?*
* *Was darf sich nicht ändern?*
* *Welche Art von Veränderung ist überhaupt legitim?*

Diese Antworten hängen **nicht** von Code ab, sondern von:

* Vision,
* Risikotoleranz,
* Zeithorizont...

Wenn sie vollständig vorgegeben wird, passiert eines von zwei Dingen:

1. folgst ihr mechanisch → das System wächst falsch.
2. weichst ab → Drift, schlechtes Gewissen, Umbauten.

Beides will man nicht.

---
**Inhaltsentscheidungen**
## Was man festlegen sollte (neue Features) wie:

❌ *“Evolution v2 bedeutet Feature X, Y, Z”*
❌ *“Ab jetzt darf Sheratan autonom lernen”*
❌ *“Das ist der nächste logische Schritt”*
❌ ...
 

---
**Veränderungsarten**
## Was ich dir **abnehmen kann** (und sollte)
eine **wasserdichte Form** geben, in der eine Evolutionsphase definiert, **ohne sich festzufahren**.

Das ist der eigentliche Trick.

---

# Minimal-Template: Evolutionsphase (drift-resistent)

> Du füllst **nur** die kursiven Stellen aus.

```text
Evolution Phase: <v2>
Base Version: Sheratan Evolution v1

Ziel dieser Phase:
<optimierung nicht durch neue Features>

Explizit erlaubt:
- <optimierung>
- <selbst dokumentation>
- <neue Gate-Automatisierung>
- <weg minimierung>

Explizit verboten:
- <änderungen an Core-API>
- <neue Gate-Regel>

Definition of Success:
- <objektiv prüfbarer Zustand>
- <Report / Test / Gate muss grün sein>

Exit-Kriterium:
- <konkretes Ereignis>
```

**Wichtig:**
beschreibt **keine Features**, sondern **Veränderungsarten**.

---

## Beispiel (nur als Form)

```text
Evolution Phase: v1.1 – Measurement Hardening
Base Version: Sheratan Evolution v1

Ziel:
Messung robuster machen, ohne Fähigkeiten zu verändern.

Explizit erlaubt:
- Verbesserung von Reports (Import, Size, Feature)
- Stabilisierung von Gates
- Dokumentation von Messergebnissen

Explizit verboten:
- Neue Job-Kinds
- Neue Policy-Dimensionen
- Entfernen bestehender Funktionalität

Definition of Success:
- Exercise + Reports laufen stabil in CI
- Keine Änderung an Core-API

Exit-Kriterium:
- Zwei aufeinanderfolgende Releases ohne Gate-Regression
```

Der Unterschied?
→ **kein neues Verhalten**, nur **bessere Kontrolle**.

---

## Dein stärkster Anti-Drift-Schutz: die “Warum-nicht?”-Frage

Für jede Änderung nach v1 stell dir **eine einzige Frage**:

> **„Warum gehört das nicht in eine neue Evolutionsphase?“**
(es giebt nur eine)
Wenn du darauf **keine saubere Antwort** hast, ist die Änderung **nicht erlaubt**.

---

## Entscheidender Punkt (bitte merken)

* **DoD** schließt einen Zustand ab
* **Evolutionsphase** erlaubt wieder Bewegung
* **Ohne definierte Phase ist jede Bewegung Drift**
