Alles klar — hier ist das **A3.0 DB + Storage Patch-Skeleton** (SQLite/WAL-freundlich, idempotent, minimal invasiv), passend zu eurem Setup mit `hosts`-Tabelle aus A2.

Ich schreibe es so, dass du es **copy/pasten** und an eure Funktionsnamen anpassen kannst.

---

# A3.0 — DB Migration (hosts: Policy-Felder)

## 1) `core/database.py` – Schema/Migration idempotent

### Ziel

`hosts` bekommt diese Spalten (Defaults so gewählt, dass Alt-Daten gültig bleiben):

* `policy_state` TEXT NOT NULL DEFAULT 'NORMAL'
* `policy_reason` TEXT NULL
* `policy_until_utc` TEXT NULL
* `policy_hits` INTEGER NOT NULL DEFAULT 0
* `policy_updated_utc` TEXT NULL
* `policy_by` TEXT NULL   *(optional, aber praktisch: "system"|"admin")*

### Migration helper

```python
# core/database.py (additions)
from __future__ import annotations

import sqlite3
from typing import Iterable

def _column_exists(conn: sqlite3.Connection, table: str, col: str) -> bool:
    cur = conn.execute(f"PRAGMA table_info({table})")
    cols = [r[1] for r in cur.fetchall()]  # (cid, name, type, notnull, dflt_value, pk)
    return col in cols

def _add_column_if_missing(conn: sqlite3.Connection, table: str, ddl: str, col: str) -> None:
    if not _column_exists(conn, table, col):
        conn.execute(f"ALTER TABLE {table} ADD COLUMN {ddl}")

def migrate_hosts_policy_fields(conn: sqlite3.Connection) -> None:
    # hosts table must exist (A2)
    _add_column_if_missing(conn, "hosts", "policy_state TEXT NOT NULL DEFAULT 'NORMAL'", "policy_state")
    _add_column_if_missing(conn, "hosts", "policy_reason TEXT", "policy_reason")
    _add_column_if_missing(conn, "hosts", "policy_until_utc TEXT", "policy_until_utc")
    _add_column_if_missing(conn, "hosts", "policy_hits INTEGER NOT NULL DEFAULT 0", "policy_hits")
    _add_column_if_missing(conn, "hosts", "policy_updated_utc TEXT", "policy_updated_utc")
    _add_column_if_missing(conn, "hosts", "policy_by TEXT", "policy_by")

def initialize_schema(conn: sqlite3.Connection) -> None:
    # ... your existing schema init ...
    # after ensuring hosts exists:
    migrate_hosts_policy_fields(conn)
    conn.commit()
```

**Warum so:** `ALTER TABLE ADD COLUMN` ist in SQLite simpel & sicher, aber du musst vorher prüfen, ob die Spalte schon existiert.

---

# A3.0 — Storage Layer (policy CRUD)

## 2) `core/storage.py` – Policy Helpers

### UTC helper (einheitlich)

```python
# core/storage.py (helpers)
from __future__ import annotations
from datetime import datetime, timezone, timedelta

def utcnow_iso() -> str:
    return datetime.now(timezone.utc).isoformat()

def utc_in_minutes(minutes: int) -> str:
    return (datetime.now(timezone.utc) + timedelta(minutes=minutes)).isoformat()
```

### `get_host` und `upsert_host` (falls du schon hast, nur erweitern)

```python
import sqlite3
from typing import Any, Dict, Optional

def get_host(conn: sqlite3.Connection, host_id: str) -> Optional[Dict[str, Any]]:
    cur = conn.execute(
        """
        SELECT host_id, status, health,
               attestation_status, drift_count, spoof_count, last_change_utc,
               policy_state, policy_reason, policy_until_utc, policy_hits, policy_updated_utc, policy_by
        FROM hosts WHERE host_id = ?
        """,
        (host_id,),
    )
    row = cur.fetchone()
    if not row:
        return None
    cols = [d[0] for d in cur.description]
    return dict(zip(cols, row))

def upsert_host(conn: sqlite3.Connection, host_id: str, fields: Dict[str, Any]) -> Dict[str, Any]:
    """
    Minimal upsert: update known columns; create row if missing.
    Assumes hosts(host_id PRIMARY KEY, ...) exists from A2.
    """
    # Ensure row exists
    conn.execute("INSERT OR IGNORE INTO hosts(host_id) VALUES (?)", (host_id,))

    # Build dynamic UPDATE for provided fields only (safe list!)
    allowed = {
        "status","health",
        "attestation_status","drift_count","spoof_count","last_change_utc",
        "policy_state","policy_reason","policy_until_utc","policy_hits","policy_updated_utc","policy_by"
    }
    set_parts = []
    params = []
    for k, v in fields.items():
        if k in allowed:
            set_parts.append(f"{k} = ?")
            params.append(v)

    if set_parts:
        sql = f"UPDATE hosts SET {', '.join(set_parts)} WHERE host_id = ?"
        params.append(host_id)
        conn.execute(sql, tuple(params))

    return get_host(conn, host_id)  # type: ignore
```

---

## 3) Policy API: set/clear/list

### `set_policy`

```python
def set_policy(
    conn: sqlite3.Connection,
    host_id: str,
    state: str,
    reason: str,
    until_utc: Optional[str],
    by: str = "system",
    increment_hits: bool = True,
) -> Dict[str, Any]:
    # Read current to preserve hits if desired
    cur = get_host(conn, host_id) or {}
    hits = int(cur.get("policy_hits", 0))

    new_hits = hits + 1 if increment_hits else hits
    fields = {
        "policy_state": state,
        "policy_reason": reason,
        "policy_until_utc": until_utc,
        "policy_hits": new_hits,
        "policy_updated_utc": utcnow_iso(),
        "policy_by": by,
    }
    upsert_host(conn, host_id, fields)
    conn.commit()
    return get_host(conn, host_id)  # type: ignore
```

### `clear_policy`

```python
def clear_policy(conn: sqlite3.Connection, host_id: str, by: str = "admin") -> Dict[str, Any]:
    fields = {
        "policy_state": "NORMAL",
        "policy_reason": None,
        "policy_until_utc": None,
        "policy_updated_utc": utcnow_iso(),
        "policy_by": by,
    }
    upsert_host(conn, host_id, fields)
    conn.commit()
    return get_host(conn, host_id)  # type: ignore
```

### `list_policies`

```python
from typing import List

def list_policies(conn: sqlite3.Connection) -> List[Dict[str, Any]]:
    cur = conn.execute(
        """
        SELECT host_id, policy_state, policy_reason, policy_until_utc, policy_hits, policy_updated_utc, policy_by
        FROM hosts
        WHERE policy_state != 'NORMAL'
        ORDER BY policy_updated_utc DESC
        """
    )
    rows = cur.fetchall()
    cols = [d[0] for d in cur.description]
    return [dict(zip(cols, r)) for r in rows]
```

### Optional: “is quarantined active?”

(Praktisch für Enforcement und Metrics)

```python
def is_quarantine_active(host: Dict[str, Any]) -> bool:
    if host.get("policy_state") != "QUARANTINED":
        return False
    until = host.get("policy_until_utc")
    if not until:
        return True  # quarantined with no TTL (should be rare)
    try:
        from datetime import datetime
        dt = datetime.fromisoformat(until)
        # if naive, treat as UTC
        if dt.tzinfo is None:
            dt = dt.replace(tzinfo=timezone.utc)
        return dt > datetime.now(timezone.utc)
    except Exception:
        return True
```

---

# A3.0 Mini-DoD (nur DB+Storage)

* [ ] `hosts` hat neue Policy-Spalten (idempotent migriert)
* [ ] `set_policy()`, `clear_policy()`, `list_policies()` funktionieren
* [ ] Commit enthält **keine** Policy Engine/Handler-Änderungen (wenn du sauber stapeln willst)

---

## Nächster Schritt (wenn du so willst)

Ich kann dir als direktes Follow-up liefern:

* **A3.1 `core/policy_engine.py` Skeleton** (pure function + escalation TTL)
* **A3.4 Admin Override Endpoints** (localhost+token)
* **A3.2 Soft Enforcement** (defer_ms) – aber nur dort, wo es bei euch wirklich Work-Pull gibt

Sag mir nur kurz: habt ihr im Core wirklich einen Endpoint, wo Nodes Arbeit “pullen” (`/mesh/pull`, `/api/jobs/pull`, o. ä.)? Dann setze ich defer_ms exakt an die richtige Stelle.
